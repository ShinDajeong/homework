<생성자>
생성자 : 아주 특별한 메소드 
객체 생성시에 호출되어 초기화
이름 = 클래스이름
리턴타입의 개념이 없음
한 클래스안에 여러개의 생성자 정의가 가능(오버로딩 : 이름은 같고 매개변수가 다름)
상속 불가 (하위 클래스는 클래스 만의 생성자가 필요하기 때문에)
클래스 내에 생상자가 단 1개도 없을 시, 자동으로 컴파일러가 기본생성자 추가해줌

<접근제어자>
private : only 자신
default : same package(package private)
protected : 남 ==> default, 자식 ==> public
public : all

<메소드 재정의>
상속받은 메소드를 다시 정의한다
전제조건 : 상속
1. 메소드 이름 같아야한다.
2. 매개변수 리스트가 같아야한다.
3. 리턴타입이 같아야한다.

<this>
메소드(instance method, non-static method), 생성자안에서 현재 실행(생성)중인
객체 자기자신을 가리키는 레퍼런스
=> 내장 변수 느낌!

1. 지역변수 or 멤버변수 이름이 같을 때 구분 => 지역변수 멤버변수(heap에할당) 다른곳에할당
	-> this.변수
	-> 자신의멤버변수를 쓸때 this사용
2. 생성자 다중 정의 되어있는 상황에서 자신의 또 다른 생성자 호출할때 
	-> this()
3. 자기자신을 다른 객체에 전달하기 위해 사용(매개변수, 리턴값으로 주기 위해)
	-> a.xxx(this)
	-> return this

부모, 자식 똑같은메소드있을때 자식이 부모 메소드 부를때 super사용

<Design Pattern> -> 설계 레시피
설계 노하우를 "이름"을 붙여서 공개한 것

Singleton Design Pattern
 => 객체가 1개만 생성되도록 하는 디자인 패턴
 => private, static 

1) 생성자 private으로 작성 
  -> 외부에서 객체생성 불가
  -> 내부에서만 객체생성 가능 (1번만)

2) 내부에서 딱 1번만 객체생성 후 레퍼런스 저장
3) 생성된 객체의 레퍼런스를 리턴해주는 메소드 작성 

nextXXX()
next() 
=> white space가 구분자가 된다 (\t, \n) 등등

nextLine()
=> \n만 구분자가 된다




